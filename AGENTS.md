# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

Before making changes, review `CONTRIBUTING.md` for commit message requirements.

## Before Committing

**IMPORTANT:** Always run `make generate` before committing changes. This command:
1. Regenerates protobuf code (Go and TypeScript)
2. Rebuilds the UI (runs `npm run build` which includes TypeScript type checking)

If `make generate` fails, fix the errors before committing. Common issues:
- TypeScript type errors in test mocks (cast mock responses with `as unknown as ...`)
- Missing protobuf imports after adding new message types

## Implementing Plans

When implementing a plan from `docs/plans/`:

1. **Mark steps complete in the plan file** - Before committing, update the plan's checklist to mark completed steps (change `- [ ]` to `- [x]`). Include the plan file in the commit.

2. **Include step identifiers in commit messages** - Put the step identifier (e.g., 1.1, 1.2, 2.1) at the END of the first line in parentheses.

Example workflow:
```bash
# 1. Implement step 1.1
# 2. Edit docs/plans/my-plan.md to mark step 1.1 as [x]
# 3. Commit both the implementation and the updated plan
git add src/file.ts docs/plans/my-plan.md
git commit -m "Add webServer configuration to playwright.config.ts (1.1)

Configure Playwright to automatically start Go backend and Vite dev
server before running E2E tests."
```

## Build Commands

```bash
make build          # Build executable to bin/holos-console
make debug          # Build with debug symbols to bin/holos-console-debug
make test           # Run all tests (Go + UI unit tests)
make test-go        # Run Go tests with race detector
make test-ui        # Run UI unit tests (one-shot)
make test-e2e       # Run E2E tests (builds binary, starts servers, runs Playwright)
make generate       # Run go generate (regenerates protobuf code + builds UI)
make tools          # Install pinned tool dependencies (buf)
make certs          # Generate TLS certificates with mkcert (one-time setup)
make run            # Build and run server with generated certificates
make dev            # Start Vite dev server with hot reload (use alongside make run)
make fmt            # Format code
make vet            # Run go vet
make lint           # Run golangci-lint
make coverage       # Generate HTML coverage report
```

### Running Single Tests

```bash
# Go: single test by name
go test -v -run TestNewHandler_Success ./console/oidc

# UI unit: by file or test name
cd ui && npm test -- SecretPage
cd ui && npm test -- -t "displays error message"

# E2E: by test name
cd ui && npx playwright test --grep "should complete full login flow"
```

## Architecture

This is a Go HTTPS server that serves a web console UI and exposes ConnectRPC services. The built UI is embedded into the Go binary via `//go:embed` for single-binary deployment.

### Package Structure

- `cmd/` - Main entrypoint, calls into cli package
- `cli/` - Cobra CLI setup with Cobra flags for listen addr, TLS, OIDC, RBAC config
- `console/` - Core server package
  - `console.go` - HTTP server setup, TLS, route registration, embedded UI serving
  - `version.go` - Version info with embedded version files and ldflags
  - `rpc/` - ConnectRPC handler implementations and auth interceptor
  - `oidc/` - Embedded Dex OIDC provider
  - `secrets/` - SecretsService with K8s backend and annotation-based RBAC
  - `ui/` - Embedded static files served at `/ui/` (build output, not source)
- `proto/` - Protobuf source files
- `gen/` - Generated protobuf Go code (do not edit)
- `ui/` - React frontend source (see UI Architecture below)

### UI Architecture

React 19 + TypeScript + Vite 7 app in the `ui/` directory.

- **UI Library**: Material UI (MUI) v7
- **Routing**: React Router v7 with basename `/ui`
- **Server state**: TanStack Query v5 with ConnectRPC Query integration (`@connectrpc/connect-query`)
- **Auth**: oidc-client-ts library with dual-mode support (dev PKCE vs BFF oauth2-proxy)
- **Generated types**: `ui/src/gen/` contains TypeScript protobuf types generated by buf

Key files:
- `ui/src/main.tsx` - Entry with TransportProvider, QueryClientProvider, BrowserRouter
- `ui/src/App.tsx` - Layout with sidebar navigation and route definitions
- `ui/src/auth/AuthProvider.tsx` - Auth context with dual-mode detection
- `ui/src/client.ts` - ConnectRPC transport setup with Bearer token injection
- `ui/src/queries/` - TanStack Query hooks for RPC calls

### Authentication

Two-mode system detected at runtime:

1. **Development (PKCE)**: Browser-side OIDC via embedded Dex at `/dex/`. Tokens stored in session storage, sent as `Authorization: Bearer` headers. Default credentials: `admin` / `verysecret` (override with `HOLOS_DEX_INITIAL_ADMIN_USERNAME`/`PASSWORD` env vars).

2. **BFF mode**: Detected by `_oauth2_proxy` cookie. oauth2-proxy handles OIDC, no tokens in frontend.

Backend auth: `LazyAuthInterceptor` in `console/rpc/auth.go` verifies JWTs and stores `rpc.Claims` in context. Lazy initialization avoids startup race with embedded Dex.

### RBAC

- **Platform-level**: OIDC groups mapped to system roles (viewer/editor/owner) via CLI flags
- **Secret-level**: Per-secret grants stored as JSON annotations on K8s Secret objects (`console.holos.run/share-users`, `console.holos.run/share-groups`)
- **Roles**: VIEWER (1), EDITOR (2), OWNER (3) defined in `proto/holos/console/v1/rbac.proto`

### Code Generation

Protobuf code is generated using buf. The `generate.go` file contains the `//go:generate buf generate` directive. After modifying `.proto` files in `proto/`, run:

```bash
make generate   # or: go generate ./...
```

This produces:
- `gen/**/*.pb.go` - Go structs for messages
- `gen/**/consolev1connect/*.connect.go` - ConnectRPC client/server bindings
- `ui/src/gen/**/*_pb.ts` - TypeScript message classes (protobuf-es)
- `ui/src/gen/**/*_connect.ts` - TypeScript ConnectRPC service definitions

### Adding New RPCs

1. Define RPC and messages in `proto/holos/console/v1/*.proto`
2. Run `make generate`
3. Implement handler method in `console/rpc/` (embed `Unimplemented*Handler` for forward compatibility)
4. Handler is auto-wired when service is registered in `console/console.go`

See `docs/rpc-service-definitions.md` for detailed examples.

### Testing Patterns

**Go tests**: Standard `*_test.go` files with table-driven tests. Uses `k8s.io/client-go/kubernetes/fake` for K8s operations. CLI integration tests use `testscript` in `console/testscript_test.go`.

**UI unit tests**: Vitest + React Testing Library + jsdom. Mock ConnectRPC clients with `vi.mock()`, cast mock responses with `as unknown as ReturnType<...>`. Setup in `ui/src/test/setup.ts`.

**E2E tests**: Playwright in `ui/e2e/`. `make test-e2e` orchestrates the full stack (builds Go binary, starts Go backend on :8443 and Vite on :5173). For iterating, start servers manually with `make run` + `make dev`, then run `cd ui && npm run test:e2e`.

### Version Management

Version is determined by:
1. `console/version/{major,minor,patch}` files (embedded at compile time)
2. `GitDescribe` ldflags override (set by Makefile during build)

Build metadata (commit, tree state, date) injected via ldflags in Makefile.

### Container Builds

Trigger container image builds using the `container.yaml` GitHub workflow. The workflow runs from `main` and accepts a `git_ref` input specifying what to check out and build:

```bash
gh workflow run container.yaml --ref main -f git_ref=refs/heads/<branch-name>
gh workflow run container.yaml --ref main -f git_ref=refs/tags/v1.2.3
```

### Tool Dependencies

Tool versions are pinned in `tools.go` using the Go tools pattern. Install with `make tools`. Currently pins: buf.

## Planning and Execution

### Feature Planning

Plan features using phases. Record plans as GitHub issues before execution using `gh issue create`.

### RED GREEN Implementation

Implement each phase using a RED GREEN approach:

1. **RED** - Write failing tests first that define the expected behavior.
2. **GREEN** - Write the minimum implementation to make the tests pass.

### Tracking Progress

When executing plans, record progress by checking off TODO items in the relevant GitHub issue using `gh issue edit` or the API. Keep issues up to date as each phase completes.

## Contributing

The GitHub issue tracker is for use by project maintainers and their agents. Features and bugs should be reported using Discord. This project operates on a best effort support model; see the LICENSE for the terms of support.
