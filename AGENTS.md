# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

Before making changes, review `CONTRIBUTING.md` for commit message requirements.

## Before Committing

**IMPORTANT:** Always run `make generate` before committing changes. This command:
1. Regenerates protobuf code (Go and TypeScript)
2. Rebuilds the UI (runs `npm run build` which includes TypeScript type checking)

If `make generate` fails, fix the errors before committing. Common issues:
- TypeScript type errors in test mocks (cast mock responses with `as unknown as ...`)
- Missing protobuf imports after adding new message types

## Implementing Plans

Plans are recorded as GitHub issues. Implement each plan on a feature branch with regular commits in a single PR that references the issue.

1. **Create a feature branch** from `main` for the plan.
2. **Make regular commits** as you work. Each commit should be a logical unit of change.
3. **Open a PR** when the work is complete. Include `Closes: #NN` (where NN is the issue number) in the PR description so the issue is automatically closed when the PR is merged.

Example workflow:
```bash
git checkout -b feat/add-playwright-config
# ... implement changes, committing as you go ...
git commit -m "Add webServer configuration to playwright.config.ts

Configure Playwright to automatically start Go backend and Vite dev
server before running E2E tests."

# Open a PR that closes the plan issue
gh pr create --title "Add Playwright E2E test infrastructure" --body "$(cat <<'EOF'
## Summary
- Configure Playwright to start Go backend and Vite dev server
- Add E2E test for the login flow

Closes: #42

## Test plan
- [ ] `make test-e2e` passes

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)
EOF
)"
```

## Build Commands

```bash
make build          # Build executable to bin/holos-console
make debug          # Build with debug symbols to bin/holos-console-debug
make test           # Run all tests (Go + UI unit tests)
make test-go        # Run Go tests with race detector
make test-ui        # Run UI unit tests (one-shot)
make test-e2e       # Run E2E tests (builds binary, starts servers, runs Playwright)
make generate       # Run go generate (regenerates protobuf code + builds UI)
make tools          # Install pinned tool dependencies (buf)
make certs          # Generate TLS certificates with mkcert (one-time setup)
make run            # Build and run server with generated certificates
make dev            # Start Vite dev server with hot reload (use alongside make run)
make dispatch ISSUE=N  # Dispatch a plan issue to a Claude Code agent in a new worktree
make fmt            # Format code
make vet            # Run go vet
make lint           # Run golangci-lint
make coverage       # Generate HTML coverage report
```

### Running Single Tests

```bash
# Go: single test by name
go test -v -run TestNewHandler_Success ./console/oidc

# UI unit: by file or test name
cd ui && npm test -- SecretPage
cd ui && npm test -- -t "displays error message"

# E2E: by test name
cd ui && npx playwright test --grep "should complete full login flow"
```

## Architecture

This is a Go HTTPS server that serves a web console UI and exposes ConnectRPC services. The built UI is embedded into the Go binary via `//go:embed` for single-binary deployment.

### Package Structure

- `cmd/` - Main entrypoint, calls into cli package
- `cli/` - Cobra CLI setup with Cobra flags for listen addr, TLS, OIDC, RBAC, logging config
- `console/` - Core server package
  - `console.go` - HTTP server setup, TLS, route registration, embedded UI serving
  - `version.go` - Version info with embedded version files and ldflags
  - `rpc/` - ConnectRPC handler implementations and auth interceptor
  - `oidc/` - Embedded Dex OIDC provider
  - `organizations/` - OrganizationService with K8s Namespace backend and annotation-based grants
  - `projects/` - ProjectService with K8s Namespace backend and annotation-based grants
  - `resolver/` - Namespace prefix resolver translating user-facing names to K8s namespace names (`{namespace-prefix}{organization-prefix}{name}` for orgs, `{namespace-prefix}{project-prefix}{name}` for projects)
  - `secrets/` - SecretsService with K8s backend and annotation-based RBAC
  - `ui/` - Embedded static files served at `/ui/` (build output, not source)
- `proto/` - Protobuf source files
- `gen/` - Generated protobuf Go code (do not edit)
- `ui/` - React frontend source (see UI Architecture below)

### UI Architecture

React 19 + TypeScript + Vite 7 app in the `ui/` directory.

- **UI Library**: Material UI (MUI) v7
- **Routing**: React Router v7 with basename `/ui`
- **Server state**: TanStack Query v5 with ConnectRPC Query integration (`@connectrpc/connect-query`)
- **Auth**: oidc-client-ts library with dual-mode support (dev PKCE vs BFF oauth2-proxy)
- **Generated types**: `ui/src/gen/` contains TypeScript protobuf types generated by buf

Key files:
- `ui/src/main.tsx` - Entry with TransportProvider, QueryClientProvider, BrowserRouter
- `ui/src/App.tsx` - Layout with sidebar navigation and route definitions
- `ui/src/auth/AuthProvider.tsx` - Auth context with dual-mode detection
- `ui/src/client.ts` - ConnectRPC transport setup with Bearer token injection
- `ui/src/queries/` - TanStack Query hooks for RPC calls

### Authentication

Two-mode system detected at runtime:

1. **Development (PKCE)**: Browser-side OIDC via embedded Dex at `/dex/`. Tokens stored in session storage, sent as `Authorization: Bearer` headers. Default credentials: `admin` / `verysecret` (override with `HOLOS_DEX_INITIAL_ADMIN_USERNAME`/`PASSWORD` env vars).

2. **BFF mode**: Detected by `_oauth2_proxy` cookie. oauth2-proxy handles OIDC, no tokens in frontend.

Backend auth: `LazyAuthInterceptor` in `console/rpc/auth.go` verifies JWTs and stores `rpc.Claims` in context. Lazy initialization avoids startup race with embedded Dex.

### RBAC

Three-tier access control model evaluated in order (highest role wins):

1. **Organization-level**: Per-org grants stored as JSON annotations on K8s Namespace objects (prefix configurable via `--organization-prefix`, default `org-`)
2. **Project-level**: Per-project grants stored as JSON annotations on K8s Namespace objects (prefix configurable via `--project-prefix`, default `prj-`)
3. **Secret-level**: Per-secret grants stored as JSON annotations on K8s Secret objects

Grant annotations: `console.holos.run/share-users`, `console.holos.run/share-groups`

Namespace prefix scheme (three-part naming: `{namespace-prefix}{type-prefix}{name}`):
- Organizations: `{namespace-prefix}{organization-prefix}{name}` (resource-type label: `organization`)
- Projects: `{namespace-prefix}{project-prefix}{name}` (resource-type label: `project`, optional organization label for IAM inheritance, project label stores project name)

The `--namespace-prefix` flag (default `"holos-"`) prefixes all console-managed namespace names, enabling multi-instance isolation in the same cluster (e.g., `prod-org-acme`, `ci-prj-api`).

Organization creation is controlled by `--disable-org-creation`, `--org-creator-users`, and `--org-creator-groups` CLI flags.

Roles: VIEWER (1), EDITOR (2), OWNER (3) defined in `proto/holos/console/v1/rbac.proto`

### Code Generation

Protobuf code is generated using buf. The `generate.go` file contains the `//go:generate buf generate` directive. After modifying `.proto` files in `proto/`, run:

```bash
make generate   # or: go generate ./...
```

This produces:
- `gen/**/*.pb.go` - Go structs for messages
- `gen/**/consolev1connect/*.connect.go` - ConnectRPC client/server bindings
- `ui/src/gen/**/*_pb.ts` - TypeScript message classes (protobuf-es)
- `ui/src/gen/**/*_connect.ts` - TypeScript ConnectRPC service definitions

### Adding New RPCs

1. Define RPC and messages in `proto/holos/console/v1/*.proto`
2. Run `make generate`
3. Implement handler method in `console/rpc/` (embed `Unimplemented*Handler` for forward compatibility)
4. Handler is auto-wired when service is registered in `console/console.go`

See `docs/rpc-service-definitions.md` for detailed examples.

### Testing Patterns

**Go tests**: Standard `*_test.go` files with table-driven tests. Uses `k8s.io/client-go/kubernetes/fake` for K8s operations. CLI integration tests use `testscript` in `console/testscript_test.go`.

**UI unit tests**: Vitest + React Testing Library + jsdom. Mock ConnectRPC clients with `vi.mock()`, cast mock responses with `as unknown as ReturnType<...>`. Setup in `ui/src/test/setup.ts`.

**E2E tests**: Playwright in `ui/e2e/`. `make test-e2e` orchestrates the full stack (builds Go binary, starts Go backend on :8443 and Vite on :5173). For iterating, start servers manually with `make run` + `make dev`, then run `cd ui && npm run test:e2e`.

### Version Management

Version is determined by:
1. `console/version/{major,minor,patch}` files (embedded at compile time)
2. `GitDescribe` ldflags override (set by Makefile during build)

Build metadata (commit, tree state, date) injected via ldflags in Makefile.

### Container Builds

Trigger container image builds using the `container.yaml` GitHub workflow. The workflow runs from `main` and accepts a `git_ref` input specifying what to check out and build:

```bash
gh workflow run container.yaml --ref main -f git_ref=refs/heads/<branch-name>
gh workflow run container.yaml --ref main -f git_ref=refs/tags/v1.2.3
```

### Tool Dependencies

Tool versions are pinned in `tools.go` using the Go tools pattern. Install with `make tools`. Currently pins: buf.

## Planning and Execution

### Feature Planning

Plan features using phases. Record plans as GitHub issues before execution using `gh issue create`.

### Dispatching Plans to Agents

After drafting a plan as a GitHub issue, dispatch it to a Claude Code agent
in a new worktree:

    scripts/dispatch <issue-number>

This creates a git worktree at ../holos-console-<N>, opens a new tmux window
named i<N>, and starts a Claude Code agent that reads the issue and implements
the plan. The script returns immediately so the main agent can continue planning.

Prerequisite: must be run inside a tmux session.

### RED GREEN Implementation

Implement each phase using a RED GREEN approach:

1. **RED** - Write failing tests first that define the expected behavior.
2. **GREEN** - Write the minimum implementation to make the tests pass.

### Final Cleanup Phase

Every plan must include a final phase to scan the entire repository for dead, deprecated, or outdated information introduced or made stale by the commits implementing the plan. This includes removing obsolete comments, unused imports, stale documentation, dead code paths, and outdated references in AGENTS.md, README files, and doc files. Commit cleanup changes separately with a clear message explaining what was removed and why.

### Tracking Progress

When executing plans, record progress by checking off TODO items in the relevant GitHub issue using `gh issue edit` or the API. Keep issues up to date as each phase completes. When the PR is merged, the `Closes: #NN` line in the PR description automatically closes the issue.

## Contributing

The GitHub issue tracker is for use by project maintainers and their agents. Features and bugs should be reported using Discord. This project operates on a best effort support model; see the LICENSE for the terms of support.
